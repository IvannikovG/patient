["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$day8.re-frame.test","~:imports",null,"~:requires",["^ ","~$re-frame.interop","^9","~$test","~$cljs.test","~$rf","~$re-frame.core","^;","^;","~$re-frame.router","^>","~$rf.router","^>","~$rf.db","~$re-frame.db","~$rf.int","^9","^A","^A","^=","^="],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$*test-timeout*",["^ ","~:meta",["^ ","~:file","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","~:line",49,"~:column",16,"~:end-line",49,"~:end-column",30,"~:dynamic",true],"^5","~$day8.re-frame.test/*test-timeout*","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",30,"^J",1,"^M",true,"^I",49,"^K",49,"~:tag","~$any"],"~$run-test-async*",["^ ","~:protocol-inline",null,"^G",["^ ","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^I",61,"^J",7,"^K",61,"^L",22,"~:arglists",["~#list",["~$quote",["^T",[["~$f"]]]]]],"^5","~$day8.re-frame.test/run-test-async*","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",22,"~:method-params",["^T",[["~$f"]]],"~:protocol-impl",null,"~:arglists-meta",["^T",[null,null]],"^J",1,"~:variadic?",false,"^I",61,"~:ret-tag","~$day8.re-frame.test/t_day8$re_frame$test3182","^K",61,"~:max-fixed-arity",1,"~:fn-var",true,"^S",["^T",["^U",["^T",[["~$f"]]]]]],"~$dequeue!",["^ ","^R",null,"^G",["^ ","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^I",16,"^J",8,"^K",16,"^L",16,"~:private",true,"^S",["^T",["^U",["^T",[["~$queue-atom"]]]]],"~:doc","Dequeue an item from a persistent queue which is stored as the value in\n  queue-atom. Returns the item, and updates the atom with the new queue\n  value. If the queue is empty, does not alter it and returns nil."],"^14",true,"^5","~$day8.re-frame.test/dequeue!","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",16,"^W",["^T",[["^15"]]],"^X",null,"^Y",["^T",[null,null]],"^J",1,"^Z",false,"^I",16,"^[",["^4",["^P","~$clj-nil"]],"^K",16,"^11",1,"^12",true,"^S",["^T",["^U",["^T",[["^15"]]]]],"^16","Dequeue an item from a persistent queue which is stored as the value in\n  queue-atom. Returns the item, and updates the atom with the new queue\n  value. If the queue is empty, does not alter it and returns nil."],"~$t_day8$re_frame$test3182",["^ ","~:num-fields",3,"~:protocols",["^4",["~$cljs.core/IFn","~$cljs.core/IMeta","~$cljs.test/IAsyncTest","~$cljs.core/IWithMeta"]],"^5","^10","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","~:type",true,"~:anonymous",true,"^J",14,"^I",97,"~:record",false,"^O","~$function","~:skip-protocol-flag",["^4",["^1<","^1=","^1?"]]],"~$->t_day8$re_frame$test3182",["^ ","^R",null,"^G",["^ ","^1A",true,"^1;",["^4",["^1<","^1=","^1>","^1?"]],"^1D",["^4",["^1<","^1=","^1?"]],"~:factory","~:positional","^S",["^T",["^U",["^T",[["~$f","~$test-context","~$meta3183"]]]]],"^16","Positional factory function for day8.re-frame.test/t_day8$re_frame$test3182.","^H",null],"^1;",["^4",["^1<","^1=","^1>","^1?"]],"^5","~$day8.re-frame.test/->t_day8$re_frame$test3182","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^W",["^T",[["~$f","^1H","^1I"]]],"^X",null,"^Y",["^T",[null,null]],"^1A",true,"^J",14,"^Z",false,"^1F","^1G","^I",97,"^[","^10","^11",3,"^12",true,"^S",["^T",["^U",["^T",[["~$f","^1H","^1I"]]]]],"^1D",["^4",["^1<","^1=","^1?"]],"^16","Positional factory function for day8.re-frame.test/t_day8$re_frame$test3182."],"~$run-test-sync",["^ ","^R",null,"^G",["^ ","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",24,"~:top-fn",["^ ","^Z",true,"~:fixed-arity",0,"^11",0,"^W",["^T",[["^T",["~$body"]]]],"^S",["^T",[["~$&","^1N"]]],"^Y",["^T",[null]]],"^J",11,"^I",288,"~:macro",true,"^K",288,"^S",["^T",["^U",["^T",[["~$&","^1N"]]]]],"^16","Execute `body` as a test, where each `dispatch` call is executed\n  synchronously (via `dispatch-sync`), and any subsequent dispatches which are\n  caused by that dispatch are also fully handled/executed prior to control flow\n  returning to your test.\n\n  Think of it kind of as though every `dispatch` in your app had been magically\n  turned into `dispatch-sync`, and re-frame had lifted the restriction that says\n  you can't call `dispatch-sync` from within an event handler.\n\n  Note that this is *not* achieved with blocking.  It relies on you not doing\n  anything asynchronous (such as an actual AJAX call or `js/setTimeout`)\n  directly in your event handlers.  In a real app running in the real browser,\n  of course that won't apply, so this might seem useless at first.  But if\n  you're a well-behaved re-framer, all of your asynchronous stuff (which is by\n  definition side-effecty) will happen in effectful event handlers installed\n  with `reg-fx`.  Which works very nicely: in your tests, install an alternative\n  version of those effectful event handlers which behaves synchronously.  For\n  maximum coolness, you might want to consider running your tests on the JVM and\n  installing a `reg-fx` handler which actually invokes your JVM Clojure\n  server-side Ring handler where your in-browser code would make an AJAX call."],"^5","~$day8.re-frame.test/run-test-sync","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",24,"^1L",["^ ","^Z",true,"^1M",0,"^11",0,"^W",["^T",[["^T",["^1N"]]]],"^S",["^T",[["~$&","^1N"]]],"^Y",["^T",[null]]],"^W",["^T",[["^T",["^1N"]]]],"^X",null,"^1M",0,"^Y",["^T",[null]],"^J",1,"^Z",true,"~:methods",[["^ ","^1M",0,"^Z",true,"^O",["^4",["~$seq","~$cljs.core/IList"]]]],"^I",288,"^1O",true,"^[","^P","^K",288,"^11",0,"^12",false,"^S",["^T",[["~$&","^1N"]]],"^16","Execute `body` as a test, where each `dispatch` call is executed\n  synchronously (via `dispatch-sync`), and any subsequent dispatches which are\n  caused by that dispatch are also fully handled/executed prior to control flow\n  returning to your test.\n\n  Think of it kind of as though every `dispatch` in your app had been magically\n  turned into `dispatch-sync`, and re-frame had lifted the restriction that says\n  you can't call `dispatch-sync` from within an event handler.\n\n  Note that this is *not* achieved with blocking.  It relies on you not doing\n  anything asynchronous (such as an actual AJAX call or `js/setTimeout`)\n  directly in your event handlers.  In a real app running in the real browser,\n  of course that won't apply, so this might seem useless at first.  But if\n  you're a well-behaved re-framer, all of your asynchronous stuff (which is by\n  definition side-effecty) will happen in effectful event handlers installed\n  with `reg-fx`.  Which works very nicely: in your tests, install an alternative\n  version of those effectful event handlers which behaves synchronously.  For\n  maximum coolness, you might want to consider running your tests on the JVM and\n  installing a `reg-fx` handler which actually invokes your JVM Clojure\n  server-side Ring handler where your in-browser code would make an AJAX call."],"~$as-callback-pred",["^ ","^R",null,"^G",["^ ","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^I",123,"^J",8,"^K",123,"^L",24,"^14",true,"^S",["^T",["^U",["^T",[["~$callback-pred"]]]]],"^16","Interprets the acceptable input values for `wait-for`'s `ok-ids` and\n  `failure-ids` params to produce a predicate function on an event.  See\n  `wait-for` for details."],"^14",true,"^5","~$day8.re-frame.test/as-callback-pred","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",24,"^W",["^T",[["^1U"]]],"^X",null,"^Y",["^T",[null,null]],"^J",1,"^Z",false,"^I",123,"^[",["^4",[null,"^1C","^18"]],"^K",123,"^11",1,"^12",true,"^S",["^T",["^U",["^T",[["^1U"]]]]],"^16","Interprets the acceptable input values for `wait-for`'s `ok-ids` and\n  `failure-ids` params to produce a predicate function on an event.  See\n  `wait-for` for details."],"~$wait-for*",["^ ","^R",null,"^G",["^ ","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^I",142,"^J",7,"^K",142,"^L",16,"^S",["^T",["^U",["^T",[["~$ok-ids","~$failure-ids","~$callback"]]]]],"^16","This function is an implementation detail: in your async tests (within a\n  `run-test-async`), you should use the `wait-for` macro instead.  (For\n  synchronous tests within `run-test-sync`, you don't need this capability at\n  all.)\n\n  Installs `callback` as a re-frame post-event callback handler, called as soon\n  as any event matching `ok-ids` is handled.  Aborts the test as a failure if\n  any event matching `failure-ids` is handled.\n\n  Since this is intended for use in asynchronous tests: it will return\n  immediately after installing the callback -- it doesn't *actually* wait.\n\n  Note that `wait-for*` tracks whether, during your callback, you call\n  `wait-for*` again.  If you *don't*, then, given the way asynchronous tests\n  work, your test must necessarily be finished.  So `wait-for*` will\n  call `(done)` for you."],"^5","~$day8.re-frame.test/wait-for*","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",16,"^W",["^T",[["^1X","^1Y","^1Z"]]],"^X",null,"^Y",["^T",[null,null]],"^J",1,"^Z",false,"^I",142,"^[",["^4",[null,"^P"]],"^K",142,"^11",3,"^12",true,"^S",["^T",["^U",["^T",[["^1X","^1Y","^1Z"]]]]],"^16","This function is an implementation detail: in your async tests (within a\n  `run-test-async`), you should use the `wait-for` macro instead.  (For\n  synchronous tests within `run-test-sync`, you don't need this capability at\n  all.)\n\n  Installs `callback` as a re-frame post-event callback handler, called as soon\n  as any event matching `ok-ids` is handled.  Aborts the test as a failure if\n  any event matching `failure-ids` is handled.\n\n  Since this is intended for use in asynchronous tests: it will return\n  immediately after installing the callback -- it doesn't *actually* wait.\n\n  Note that `wait-for*` tracks whether, during your callback, you call\n  `wait-for*` again.  If you *don't*, then, given the way asynchronous tests\n  work, your test must necessarily be finished.  So `wait-for*` will\n  call `(done)` for you."],"~$run-test-async",["^ ","^R",null,"^G",["^ ","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",25,"^1L",["^ ","^Z",true,"^1M",0,"^11",0,"^W",["^T",[["^T",["^1N"]]]],"^S",["^T",[["~$&","^1N"]]],"^Y",["^T",[null]]],"^J",11,"^I",103,"^1O",true,"^K",103,"^S",["^T",["^U",["^T",[["~$&","^1N"]]]]],"^16","Run `body` as an async re-frame test. The async nature means you'll need to\n  use `wait-for` any time you want to make any assertions that should be true\n  *after* an event has been handled.  It's assumed that there will be at least\n  one `wait-for` in the body of your test (otherwise you don't need this macro\n  at all).\n\n  Note: unlike regular ClojureScript `cljs.test/async` tests, `wait-for` takes\n  care of calling `(done)` for you: you don't need to do anything specific to\n  handle the fact that your test is asynchronous, other than make sure that all\n  your assertions happen with `wait-for` blocks.\n\n  This macro will automatically clean up any changes to re-frame state made\n  within the test body, as per `with-temp-re-frame-state` (except that the way\n  it's done here *does* work for async tests, whereas that macro used by itself\n  doesn't)."],"^5","~$day8.re-frame.test/run-test-async","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",25,"^1L",["^ ","^Z",true,"^1M",0,"^11",0,"^W",["^T",[["^T",["^1N"]]]],"^S",["^T",[["~$&","^1N"]]],"^Y",["^T",[null]]],"^W",["^T",[["^T",["^1N"]]]],"^X",null,"^1M",0,"^Y",["^T",[null]],"^J",1,"^Z",true,"^1Q",[["^ ","^1M",0,"^Z",true,"^O",["^4",["^1R","^1S"]]]],"^I",103,"^1O",true,"^[","^P","^K",103,"^11",0,"^12",false,"^S",["^T",[["~$&","^1N"]]],"^16","Run `body` as an async re-frame test. The async nature means you'll need to\n  use `wait-for` any time you want to make any assertions that should be true\n  *after* an event has been handled.  It's assumed that there will be at least\n  one `wait-for` in the body of your test (otherwise you don't need this macro\n  at all).\n\n  Note: unlike regular ClojureScript `cljs.test/async` tests, `wait-for` takes\n  care of calling `(done)` for you: you don't need to do anything specific to\n  handle the fact that your test is asynchronous, other than make sure that all\n  your assertions happen with `wait-for` blocks.\n\n  This macro will automatically clean up any changes to re-frame state made\n  within the test body, as per `with-temp-re-frame-state` (except that the way\n  it's done here *does* work for async tests, whereas that macro used by itself\n  doesn't)."],"~$run-test-sync*",["^ ","^R",null,"^G",["^ ","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^I",270,"^J",7,"^K",270,"^L",21,"^S",["^T",["^U",["^T",[["~$f"]]]]]],"^5","~$day8.re-frame.test/run-test-sync*","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",21,"^W",["^T",[["~$f"]]],"^X",null,"^Y",["^T",[null,null]],"^J",1,"^Z",false,"^I",270,"^K",270,"^11",1,"^12",true,"^S",["^T",["^U",["^T",[["~$f"]]]]]],"~$*test-context*",["^ ","^G",["^ ","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^I",51,"^J",38,"^K",51,"^L",52,"^M",true,"^14",true],"^14",true,"^5","~$day8.re-frame.test/*test-context*","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",52,"^J",1,"^M",true,"^I",51,"^K",51,"^O","^P","^16","~`*test-context*` is used to communicate internal details of the test between\n  `run-test-async*` and `wait-for*`. It is dynamically bound so that it doesn't\n  need to appear as a lexical argument to a `wait-for` block, since we don't\n  want it to be visible when you're writing tests.  But care must be taken to\n  pass it around lexically across callbacks, since ClojureScript doesn't have\n  `bound-fn`."],"~$*handling*",["^ ","^G",["^ ","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^I",268,"^J",38,"^K",268,"^L",48,"^M",true,"^14",true],"^14",true,"^5","~$day8.re-frame.test/*handling*","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",48,"^J",1,"^M",true,"^I",268,"^K",268,"^O","^P"],"~$wait-for",["^ ","^R",null,"^G",["^ ","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",19,"^1L",["^ ","^Z",true,"^1M",1,"^11",1,"^W",["^T",[["^T",[["~$ids","^1Y","~$event-sym","~:as","~$argv"],"^1N"]]]],"^S",["^T",[[["^29","^1Y","^2:","^2;","^2<"],"~$&","^1N"]]],"^Y",["^T",[null]]],"^J",11,"^I",206,"^1O",true,"^K",206,"^S",["^T",["^U",["^T",[[["^29","^1Y","^2:","^2;","^2<"],"~$&","^1N"]]]]],"^16","Execute `body` once an event identified by the predicate(s) `ids` has been handled.\n\n  `ids` and `failure-ids` are means to identify an event. Normally, each would\n  be a simple keyword or a set of keywords.  If an event with event-id of (or\n  in) `ids` is handled, the test will continue by executing the body. If an\n  event with an event-id of (or in) `failure-ids` is handled, the test will\n  abort and fail.\n\n  IMPORTANT NOTE: due to the way async tests in re-frame work, code you want\n  executed after the event you're waiting for has to happen in the `body` of the\n  `wait-for` (in an implicit callback), not just lexically after the the\n  `wait-for` call. In practice, this means `wait-for` must always be in a tail\n  position.\n\n  Eg:\n      (run-test-async\n        (dispatch [:get-user 2])\n        (wait-for [#{:got-user} #{:no-such-user :system-unavailable} event]\n          (is (= (:username @(subscribe [:user])) \"johnny\")))\n        ;; Don't put code here, it will run *before* the event you're waiting\n        ;; for.\n        )\n\n  Acceptable inputs for `ids` and `failure-ids` are:\n    - `:some-event-id` => matches an event with that ID\n\n    - `#{:some-event-id :other-event-id}` => matches an event with any of the\n                                             given IDs\n\n    - `[:some-event-id :other-event-id]` => ditto (checks in order)\n\n    - `(fn [event] ,,,) => uses the function as a predicate\n\n    - `[(fn [event] ,,,) (fn [event] ,,,)]` => tries each predicate in turn,\n                                               matching an event which matches\n                                               at least one predicate\n\n    - `#{:some-event-id (fn [event] ,,,)}` => tries each\n\n  Note that because we're liberal about whether you supply `failure-ids` and/or\n  `event-sym`, if you do choose to supply only one, and you want that one to be\n  `event-sym`, you can't supply it as a destructuring form (because we can't\n  disambiguate that from a vector of `failure-ids`).  You can just supply `nil`\n  as `failure-ids` in this case, and then you'll be able to destructure."],"^5","~$day8.re-frame.test/wait-for","^H","/Users/georgii/.cljs/.aot_cache/1.10.773/5090527/day8/re_frame/test.cljc","^L",19,"^1L",["^ ","^Z",true,"^1M",1,"^11",1,"^W",["^T",[["^T",[["^29","^1Y","^2:","^2;","^2<"],"^1N"]]]],"^S",["^T",[[["^29","^1Y","^2:","^2;","^2<"],"~$&","^1N"]]],"^Y",["^T",[null]]],"^W",["^T",[["^T",[["^29","^1Y","^2:","^2;","^2<"],"^1N"]]]],"^X",null,"^1M",1,"^Y",["^T",[null]],"^J",1,"^Z",true,"^1Q",[["^ ","^1M",1,"^Z",true,"^O",["^4",["^1R","^1S"]]]],"^I",206,"^1O",true,"^[","^P","^K",206,"^11",1,"^12",false,"^S",["^T",[[["^29","^1Y","^2:","^2;","^2<"],"~$&","^1N"]]],"^16","Execute `body` once an event identified by the predicate(s) `ids` has been handled.\n\n  `ids` and `failure-ids` are means to identify an event. Normally, each would\n  be a simple keyword or a set of keywords.  If an event with event-id of (or\n  in) `ids` is handled, the test will continue by executing the body. If an\n  event with an event-id of (or in) `failure-ids` is handled, the test will\n  abort and fail.\n\n  IMPORTANT NOTE: due to the way async tests in re-frame work, code you want\n  executed after the event you're waiting for has to happen in the `body` of the\n  `wait-for` (in an implicit callback), not just lexically after the the\n  `wait-for` call. In practice, this means `wait-for` must always be in a tail\n  position.\n\n  Eg:\n      (run-test-async\n        (dispatch [:get-user 2])\n        (wait-for [#{:got-user} #{:no-such-user :system-unavailable} event]\n          (is (= (:username @(subscribe [:user])) \"johnny\")))\n        ;; Don't put code here, it will run *before* the event you're waiting\n        ;; for.\n        )\n\n  Acceptable inputs for `ids` and `failure-ids` are:\n    - `:some-event-id` => matches an event with that ID\n\n    - `#{:some-event-id :other-event-id}` => matches an event with any of the\n                                             given IDs\n\n    - `[:some-event-id :other-event-id]` => ditto (checks in order)\n\n    - `(fn [event] ,,,) => uses the function as a predicate\n\n    - `[(fn [event] ,,,) (fn [event] ,,,)]` => tries each predicate in turn,\n                                               matching an event which matches\n                                               at least one predicate\n\n    - `#{:some-event-id (fn [event] ,,,)}` => tries each\n\n  Note that because we're liberal about whether you supply `failure-ids` and/or\n  `event-sym`, if you do choose to supply only one, and you want that one to be\n  `event-sym`, you can't supply it as a destructuring form (because we can't\n  disambiguate that from a vector of `failure-ids`).  You can just supply `nil`\n  as `failure-ids` in this case, and then you'll be able to destructure."]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^6","^6","^:","^;","^;","^;"],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:max-wait-for-depth","^1H","~:done","~:else","~:now-waiting-for","^H","^1[","^L","^V","^1@","~:wait-for-depth","^J","~:fail","^I","~$fail-pred","~:callback-pred","~$not","^23","~:expected","~$cljs.core/fn","^1I","^K","~:error","~$event","~:pass","~:actual","~:message","~$f"]],"~:order",["^2F","^2B","^2E","^2C","~$f","^1H","^1I","^V","^2L","^2D","^2I","^H","^L","^1@","^J","^I","^2K","^K","^2P","^2Q","^2M","^2J","^2H","^2N","^2O","^2G","^1[","^23"]],"^16",null]